const e=[],t=new WeakMap,r=(e,t)=>{for(const o in e)"object"==typeof e[o]&&(e[o]=r(e[o],t));const o=new Proxy(e,{get(e,r,o){const n=Reflect.get(e,r,o);return t.onGet(e,r,o),n},set(e,o,n,c){"object"==typeof n&&(n=r(n,t));const s=Reflect.set(e,o,n,c);return t.onSet(e,o,n,c),s},deleteProperty(e,r){const o=Reflect.deleteProperty(e,r);return t.onDeleteProperty(e,r),o}});return Array.isArray(e)&&Object.setPrototypeOf(o,Array.prototype),o},o=(r,o)=>{if(!e.length)return;let n=t.get(r);n||(n=new Map,t.set(r,n));let c=n.get(o);c||(c=new Set,n.set(o,c)),e.forEach((e=>c.add(e)))},n=(e,r)=>{const o=t.get(e);if(!o)return;const n=o.get(r);n&&n.forEach((e=>{e()}))},c=t=>{e.push(t),t(),e.pop()},s=e=>r(e,{onGet(e,t){o(e,t)},onSet(e,t){n(e,t)},onDeleteProperty(){}}),l=e=>{const t={get value(){return o(t,"value"),e},set value(r){r!==e&&(e=r,n(t,"value"))}};return t},u=e=>{const t=l(null);return c((()=>t.value=e())),t};export{u as computed,r as getTrackableObject,s as reactive,l as ref,t as targetMap,o as track,n as trigger,c as watchEffect};
//# sourceMappingURL=reactivity.js.map
