{"version":3,"sources":["../source/AsYouTypeFormatter.PatternMatcher.js"],"names":["PatternMatcher","pattern","matchTree","PatternParser","parse","string","allowOverflow","Error","result","match","split","matchedChars","overflow","characters","tree","last","length","characterString","join","indexOf","partialMatch","slice","Array","isArray","restCharacters","i","subtree","JSON","stringify","op","args","branch","char","OPERATOR","RegExp","ILLEGAL_CHARACTER_REGEXP","context","or","instructions","parsePattern","branches","concat","push","pop","test","getContext","operator","before","index","rightPart","startContext","endContext","oneOfSet","parseOneOfSet","values","prevValue","charCodeAt","nextValue","value","String","fromCharCode"],"mappings":";;;;;;;;;;;;;IAAqBA,c;;;AACpB,0BAAYC,OAAZ,EAAqB;AAAA;;AACpB,SAAKC,SAAL,GAAiB,IAAIC,aAAJ,GAAoBC,KAApB,CAA0BH,OAA1B,CAAjB;AACA;;;;0BAEKI,M,EAAgC;AAAA,qFAAJ,EAAI;AAAA,UAAtBC,aAAsB,QAAtBA,aAAsB;;AACrC,UAAI,CAACD,MAAL,EAAa;AACZ,cAAM,IAAIE,KAAJ,CAAU,oBAAV,CAAN;AACA;;AACD,UAAMC,MAAM,GAAGC,MAAK,CAACJ,MAAM,CAACK,KAAP,CAAa,EAAb,CAAD,EAAmB,KAAKR,SAAxB,EAAmC,IAAnC,CAApB;;AACA,UAAIM,MAAM,IAAIA,MAAM,CAACC,KAArB,EAA4B;AAC3B,eAAOD,MAAM,CAACG,YAAd;AACA;;AACD,UAAIH,MAAM,IAAIA,MAAM,CAACI,QAArB,EAA+B;AAC9B,YAAI,CAACN,aAAL,EAAoB;AACnB;AACA;AACD;;AACD,aAAOE,MAAP;AACA;;;;;;;;AAGF,SAASC,MAAT,CAAeI,UAAf,EAA2BC,IAA3B,EAAiCC,IAAjC,EAAuC;AACtC,MAAI,OAAOD,IAAP,KAAgB,QAApB,EAA8B;AAC7B,QAAIC,IAAJ,EAAU;AACT;AACA,UAAIF,UAAU,CAACG,MAAX,GAAoBF,IAAI,CAACE,MAA7B,EAAqC;AACpC,eAAO;AACNJ,UAAAA,QAAQ,EAAE;AADJ,SAAP;AAGA;AACD;;AACD,QAAMK,eAAe,GAAGJ,UAAU,CAACK,IAAX,CAAgB,EAAhB,CAAxB;;AACA,QAAIJ,IAAI,CAACK,OAAL,CAAaF,eAAb,MAAkC,CAAtC,EAAyC;AACxC;AACA;AACA;;AACA;AACA,UAAIJ,UAAU,CAACG,MAAX,KAAsBF,IAAI,CAACE,MAA/B,EAAuC;AACtC,eAAO;AACNP,UAAAA,KAAK,EAAE,IADD;AAENE,UAAAA,YAAY,EAAEE;AAFR,SAAP;AAIA,OAVuC,CAWxC;AACA;AACA;;AACA;;;AACA,aAAO;AACNO,QAAAA,YAAY,EAAE,IADR,CAEN;;AAFM,OAAP;AAIA;;AACD,QAAIH,eAAe,CAACE,OAAhB,CAAwBL,IAAxB,MAAkC,CAAtC,EAAyC;AACxC,aAAO;AACNL,QAAAA,KAAK,EAAE,IADD;AAENE,QAAAA,YAAY,EAAEE,UAAU,CAACQ,KAAX,CAAiB,CAAjB,EAAoBP,IAAI,CAACE,MAAzB;AAFR,OAAP;AAIA;;AACD;AACA;;AAED,MAAIM,KAAK,CAACC,OAAN,CAAcT,IAAd,CAAJ,EAAyB;AACxB,QAAIU,cAAc,GAAGX,UAAU,CAACQ,KAAX,EAArB;AACA,QAAII,CAAC,GAAG,CAAR;;AACA,WAAOA,CAAC,GAAGX,IAAI,CAACE,MAAhB,EAAwB;AACvB,UAAMU,OAAO,GAAGZ,IAAI,CAACW,CAAD,CAApB;;AACA,UAAMjB,MAAM,GAAGC,MAAK,CAACe,cAAD,EAAiBE,OAAjB,EAA0BX,IAAI,IAAKU,CAAC,KAAKX,IAAI,CAACE,MAAL,GAAc,CAAvD,CAApB;;AACA,UAAI,CAACR,MAAL,EAAa;AACZ;AACA,OAFD,MAEO,IAAIA,MAAM,CAACI,QAAX,EAAqB;AAC3B,eAAOJ,MAAP;AACA,OAFM,MAEA,IAAIA,MAAM,CAACC,KAAX,EAAkB;AACxB;AACAe,QAAAA,cAAc,GAAGA,cAAc,CAACH,KAAf,CAAqBb,MAAM,CAACG,YAAP,CAAoBK,MAAzC,CAAjB;;AACA,YAAIQ,cAAc,CAACR,MAAf,KAA0B,CAA9B,EAAiC;AAChC,cAAIS,CAAC,KAAKX,IAAI,CAACE,MAAL,GAAc,CAAxB,EAA2B;AAC1B,mBAAO;AACNP,cAAAA,KAAK,EAAE,IADD;AAENE,cAAAA,YAAY,EAAEE;AAFR,aAAP;AAIA,WALD,MAKO;AACN,mBAAO;AACNO,cAAAA,YAAY,EAAE,IADR,CAEN;;AAFM,aAAP;AAIA;AACD;AACD,OAhBM,MAgBA;AACN;AACA,YAAIZ,MAAM,CAACY,YAAX,EAAyB;AACxB,iBAAO;AACNA,YAAAA,YAAY,EAAE,IADR,CAEN;;AAFM,WAAP;AAIA,SALD,MAKO;AACN,gBAAM,IAAIb,KAAJ,sCAAwCoB,IAAI,CAACC,SAAL,CAAepB,MAAf,EAAuB,IAAvB,EAA6B,CAA7B,CAAxC,EAAN;AACA;AACD;;AACDiB,MAAAA,CAAC;AACD,KAtCuB,CAuCxB;AACA;;AACA;;;AACA,QAAIV,IAAJ,EAAU;AACT,aAAO;AACNH,QAAAA,QAAQ,EAAE;AADJ,OAAP;AAGA;;AACD,WAAO;AACNH,MAAAA,KAAK,EAAE,IADD;AAENE,MAAAA,YAAY,EAAEE,UAAU,CAACQ,KAAX,CAAiB,CAAjB,EAAoBR,UAAU,CAACG,MAAX,GAAoBQ,cAAc,CAACR,MAAvD;AAFR,KAAP;AAIA;;AAED,UAAQF,IAAI,CAACe,EAAb;AACC,SAAK,GAAL;AACC,UAAIT,YAAJ;;AACA,2BAAqBN,IAAI,CAACgB,IAA1B,kHAAgC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,YAArBC,MAAqB;;AAC/B,YAAMvB,OAAM,GAAGC,MAAK,CAACI,UAAD,EAAakB,MAAb,EAAqBhB,IAArB,CAApB;;AACA,YAAIP,OAAJ,EAAY;AACX,cAAIA,OAAM,CAACI,QAAX,EAAqB;AACpB,mBAAOJ,OAAP;AACA,WAFD,MAEO,IAAIA,OAAM,CAACC,KAAX,EAAkB;AACxB,mBAAO;AACNA,cAAAA,KAAK,EAAE,IADD;AAENE,cAAAA,YAAY,EAAEH,OAAM,CAACG;AAFf,aAAP;AAIA,WALM,MAKA;AACN;AACA,gBAAIH,OAAM,CAACY,YAAX,EAAyB;AACxBA,cAAAA,YAAY,GAAG,IAAf;AACA,aAFD,MAEO;AACN,oBAAM,IAAIb,KAAJ,sCAAwCoB,IAAI,CAACC,SAAL,CAAepB,OAAf,EAAuB,IAAvB,EAA6B,CAA7B,CAAxC,EAAN;AACA;AACD;AACD;AACD;;AACD,UAAIY,YAAJ,EAAkB;AACjB,eAAO;AACNA,UAAAA,YAAY,EAAE,IADR,CAEN;;AAFM,SAAP;AAIA,OA3BF,CA4BC;;;AACA;;AAED,SAAK,IAAL;AACC,4BAAmBN,IAAI,CAACgB,IAAxB,yHAA8B;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,YAAnBE,KAAmB;;AAC7B,YAAInB,UAAU,CAAC,CAAD,CAAV,KAAkBmB,KAAtB,EAA4B;AAC3B,cAAInB,UAAU,CAACG,MAAX,KAAsB,CAA1B,EAA6B;AAC5B,mBAAO;AACNP,cAAAA,KAAK,EAAE,IADD;AAENE,cAAAA,YAAY,EAAEE;AAFR,aAAP;AAIA;;AACD,cAAIE,IAAJ,EAAU;AACT,mBAAO;AACNH,cAAAA,QAAQ,EAAE;AADJ,aAAP;AAGA;;AACD,iBAAO;AACNH,YAAAA,KAAK,EAAE,IADD;AAENE,YAAAA,YAAY,EAAE,CAACqB,KAAD;AAFR,WAAP;AAIA;AACD,OAnBF,CAoBC;;;AACA;;AAED;;AACA;AACC,YAAM,IAAIzB,KAAJ,yCAA2CO,IAA3C,EAAN;AAzDF;AA2DA;;AAED,IAAMmB,QAAQ,GAAG,IAAIC,MAAJ,EAChB;AACA,MACC;AACA,KAFD,GAGC;AACA,GAJD,GAKC;AACA,WAND,GAOC;AACA,GARD,GASC;AACA,KAVD,GAWC;AACA,GAZD,GAaC;AACA,KAdD,GAeC;AACA,GAhBD,GAiBC;AACA,KAlBD,GAmBA,GArBgB,CAAjB;AAwBA,IAAMC,wBAAwB,GAAG,kBAAjC;;IAEMhC,a;;;;;;;;;0BACCF,O,EAAS;AACd,WAAKmC,OAAL,GAAe,CAAC;AACfC,QAAAA,EAAE,EAAE,IADW;AAEfC,QAAAA,YAAY,EAAE;AAFC,OAAD,CAAf;AAKA,WAAKC,YAAL,CAAkBtC,OAAlB;;AAEA,UAAI,KAAKmC,OAAL,CAAapB,MAAb,KAAwB,CAA5B,EAA+B;AAC9B,cAAM,IAAIT,KAAJ,CAAU,sDAAV,CAAN;AACA;;AAVa,2BAYqB,KAAK6B,OAAL,CAAa,CAAb,CAZrB;AAAA,UAYNI,QAZM,kBAYNA,QAZM;AAAA,UAYIF,YAZJ,kBAYIA,YAZJ;;AAcd,UAAIE,QAAJ,EAAc;AACb,eAAO,CAAC;AACPX,UAAAA,EAAE,EAAE,GADG;AAEPC,UAAAA,IAAI,EAAEU,QAAQ,CAACC,MAAT,CAAgB,CAACH,YAAD,CAAhB;AAFC,SAAD,CAAP;AAIA;AAED;;;AACA,UAAIA,YAAY,CAACtB,MAAb,KAAwB,CAA5B,EAA+B;AAC9B,cAAM,IAAIT,KAAJ,CAAU,qBAAV,CAAN;AACA;;AAED,aAAO+B,YAAP;AACA;;;iCAEYF,O,EAAS;AACrB,WAAKA,OAAL,CAAaM,IAAb,CAAkBN,OAAlB;AACA;;;iCAEY;AACZ,WAAKA,OAAL,CAAaO,GAAb;AACA;;;iCAEY;AACZ,aAAO,KAAKP,OAAL,CAAa,KAAKA,OAAL,CAAapB,MAAb,GAAsB,CAAnC,CAAP;AACA;;;iCAEYf,O,EAAS;AACrB,UAAI,CAACA,OAAL,EAAc;AACb,cAAM,IAAIM,KAAJ,CAAU,qBAAV,CAAN;AACA;;AAED,UAAME,KAAK,GAAGR,OAAO,CAACQ,KAAR,CAAcwB,QAAd,CAAd;;AACA,UAAI,CAACxB,KAAL,EAAY;AACX,YAAI0B,wBAAwB,CAACS,IAAzB,CAA8B3C,OAA9B,CAAJ,EAA4C;AAC3C,gBAAM,IAAIM,KAAJ,kDAAoDN,OAApD,EAAN;AACA;;AACD,aAAK4C,UAAL,GAAkBP,YAAlB,GAAiC,KAAKO,UAAL,GAAkBP,YAAlB,CAA+BG,MAA/B,CAChCxC,OAAO,CAACS,KAAR,CAAc,EAAd,CADgC,CAAjC;AAGA;AACA;;AAED,UAAMoC,QAAQ,GAAGrC,KAAK,CAAC,CAAD,CAAtB;AACA,UAAMsC,MAAM,GAAG9C,OAAO,CAACoB,KAAR,CAAc,CAAd,EAAiBZ,KAAK,CAACuC,KAAvB,CAAf;AACA,UAAMC,SAAS,GAAGhD,OAAO,CAACoB,KAAR,CAAcZ,KAAK,CAACuC,KAAN,GAAcF,QAAQ,CAAC9B,MAArC,CAAlB;;AAEA,cAAQ8B,QAAR;AACC,aAAK,KAAL;AACC,cAAIC,MAAJ,EAAY;AACX,iBAAKR,YAAL,CAAkBQ,MAAlB;AACA;;AACD,eAAKG,YAAL,CAAkB;AACjBb,YAAAA,EAAE,EAAE,IADa;AAEjBC,YAAAA,YAAY,EAAE,EAFG;AAGjBE,YAAAA,QAAQ,EAAE;AAHO,WAAlB;AAKA;;AAED,aAAK,GAAL;AACC,cAAI,CAAC,KAAKK,UAAL,GAAkBR,EAAvB,EAA2B;AAC1B,kBAAM,IAAI9B,KAAJ,CAAU,iDAAV,CAAN;AACA;;AACD,cAAIwC,MAAJ,EAAY;AACX,iBAAKR,YAAL,CAAkBQ,MAAlB;AACA;;AACD,cAAI,KAAKF,UAAL,GAAkBP,YAAlB,CAA+BtB,MAA/B,KAA0C,CAA9C,EAAiD;AAChD,kBAAM,IAAIT,KAAJ,CAAU,2DAAV,CAAN;AACA;;AATF,iCAUsB,KAAKsC,UAAL,EAVtB;AAAA,cAUSL,QAVT,oBAUSA,QAVT;;AAWCA,UAAAA,QAAQ,CAACE,IAAT,CACC,KAAKG,UAAL,GAAkBP,YADnB;AAGA,eAAKa,UAAL;AACA,eAAKN,UAAL,GAAkBP,YAAlB,CAA+BI,IAA/B,CAAoC;AACnCb,YAAAA,EAAE,EAAE,GAD+B;AAEnCC,YAAAA,IAAI,EAAEU;AAF6B,WAApC;AAIA;;AAED,aAAK,GAAL;AACC,cAAI,CAAC,KAAKK,UAAL,GAAkBR,EAAvB,EAA2B;AAC1B,kBAAM,IAAI9B,KAAJ,CAAU,kDAAV,CAAN;AACA;;AACD,cAAIwC,MAAJ,EAAY;AACX,iBAAKR,YAAL,CAAkBQ,MAAlB;AACA,WANF,CAOC;;;AACA,cAAI,CAAC,KAAKF,UAAL,GAAkBL,QAAvB,EAAiC;AAChC;;AACA;AACA,gBAAI,KAAKJ,OAAL,CAAapB,MAAb,KAAwB,CAA5B,EAA+B;AAC9B,mBAAK6B,UAAL,GAAkBL,QAAlB,GAA6B,EAA7B;AACA,aAFD,MAEO;AACN,oBAAM,IAAIjC,KAAJ,CAAU,+CAAV,CAAN;AACA;AACD;;AACD,eAAKsC,UAAL,GAAkBL,QAAlB,CAA2BE,IAA3B,CACC,KAAKG,UAAL,GAAkBP,YADnB;AAGA,eAAKO,UAAL,GAAkBP,YAAlB,GAAiC,EAAjC;AACA;;AAED,aAAK,GAAL;AACC,cAAIS,MAAJ,EAAY;AACX,iBAAKR,YAAL,CAAkBQ,MAAlB;AACA;;AACD,eAAKG,YAAL,CAAkB;AACjBE,YAAAA,QAAQ,EAAE;AADO,WAAlB;AAGA;;AAED,aAAK,GAAL;AACC,cAAI,CAAC,KAAKP,UAAL,GAAkBO,QAAvB,EAAiC;AAChC,kBAAM,IAAI7C,KAAJ,CAAU,+CAAV,CAAN;AACA;;AACD,eAAK4C,UAAL;AACA,eAAKN,UAAL,GAAkBP,YAAlB,CAA+BI,IAA/B,CAAoC;AACnCb,YAAAA,EAAE,EAAE,IAD+B;AAEnCC,YAAAA,IAAI,EAAEuB,aAAa,CAACN,MAAD;AAFgB,WAApC;AAIA;;AAED;;AACA;AACC,gBAAM,IAAIxC,KAAJ,6BAA+BuC,QAA/B,EAAN;AA9EF;;AAiFA,UAAIG,SAAJ,EAAe;AACd,aAAKV,YAAL,CAAkBU,SAAlB;AACA;AACD;;;;;;AAGF,SAASI,aAAT,CAAuBpD,OAAvB,EAAgC;AAC/B,MAAMqD,MAAM,GAAG,EAAf;AACA,MAAI7B,CAAC,GAAG,CAAR;;AACA,SAAOA,CAAC,GAAGxB,OAAO,CAACe,MAAnB,EAA2B;AAC1B,QAAIf,OAAO,CAACwB,CAAD,CAAP,KAAe,GAAnB,EAAwB;AACvB,UAAIA,CAAC,KAAK,CAAN,IAAWA,CAAC,KAAKxB,OAAO,CAACe,MAAR,GAAiB,CAAtC,EAAyC;AACxC,cAAM,IAAIT,KAAJ,gDAAkDN,OAAlD,EAAN;AACA;;AACD,UAAMsD,SAAS,GAAGtD,OAAO,CAACwB,CAAC,GAAG,CAAL,CAAP,CAAe+B,UAAf,CAA0B,CAA1B,IAA+B,CAAjD;AACA,UAAMC,SAAS,GAAGxD,OAAO,CAACwB,CAAC,GAAG,CAAL,CAAP,CAAe+B,UAAf,CAA0B,CAA1B,IAA+B,CAAjD;AACA,UAAIE,KAAK,GAAGH,SAAZ;;AACA,aAAOG,KAAK,IAAID,SAAhB,EAA2B;AAC1BH,QAAAA,MAAM,CAACZ,IAAP,CAAYiB,MAAM,CAACC,YAAP,CAAoBF,KAApB,CAAZ;AACAA,QAAAA,KAAK;AACL;AACD,KAXD,MAWO;AACNJ,MAAAA,MAAM,CAACZ,IAAP,CAAYzC,OAAO,CAACwB,CAAD,CAAnB;AACA;;AACDA,IAAAA,CAAC;AACD;;AACD,SAAO6B,MAAP;AACA","sourcesContent":["export default class PatternMatcher {\r\n\tconstructor(pattern) {\r\n\t\tthis.matchTree = new PatternParser().parse(pattern)\r\n\t}\r\n\r\n\tmatch(string, { allowOverflow } = {}) {\r\n\t\tif (!string) {\r\n\t\t\tthrow new Error('String is required')\r\n\t\t}\r\n\t\tconst result = match(string.split(''), this.matchTree, true)\r\n\t\tif (result && result.match) {\r\n\t\t\tdelete result.matchedChars\r\n\t\t}\r\n\t\tif (result && result.overflow) {\r\n\t\t\tif (!allowOverflow) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result\r\n\t}\r\n}\r\n\r\nfunction match(characters, tree, last) {\r\n\tif (typeof tree === 'string') {\r\n\t\tif (last) {\r\n\t\t\t// `tree` is always a single character.\r\n\t\t\tif (characters.length > tree.length) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\toverflow: true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst characterString = characters.join('')\r\n\t\tif (tree.indexOf(characterString) === 0) {\r\n\t\t\t// `tree` is always a single character.\r\n\t\t\t// If `tree.indexOf(characterString) === 0`\r\n\t\t\t// then `characters.length === tree.length`.\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif (characters.length === tree.length) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tmatch: true,\r\n\t\t\t\t\tmatchedChars: characters\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// `tree` is always a single character.\r\n\t\t\t// If `tree.indexOf(characterString) === 0`\r\n\t\t\t// then `characters.length === tree.length`.\r\n\t\t\t/* istanbul ignore next */\r\n\t\t\treturn {\r\n\t\t\t\tpartialMatch: true,\r\n\t\t\t\t// matchedChars: characters\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (characterString.indexOf(tree) === 0) {\r\n\t\t\treturn {\r\n\t\t\t\tmatch: true,\r\n\t\t\t\tmatchedChars: characters.slice(0, tree.length)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\r\n\tif (Array.isArray(tree)) {\r\n\t\tlet restCharacters = characters.slice()\r\n\t\tlet i = 0\r\n\t\twhile (i < tree.length) {\r\n\t\t\tconst subtree = tree[i]\r\n\t\t\tconst result = match(restCharacters, subtree, last && (i === tree.length - 1))\r\n\t\t\tif (!result) {\r\n\t\t\t\treturn\r\n\t\t\t} else if (result.overflow) {\r\n\t\t\t\treturn result\r\n\t\t\t} else if (result.match) {\r\n\t\t\t\t// Continue with the next subtree with the rest of the characters.\r\n\t\t\t\trestCharacters = restCharacters.slice(result.matchedChars.length)\r\n\t\t\t\tif (restCharacters.length === 0) {\r\n\t\t\t\t\tif (i === tree.length - 1) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\t\tmatchedChars: characters\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tpartialMatch: true,\r\n\t\t\t\t\t\t\t// matchedChars: characters\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif (result.partialMatch) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tpartialMatch: true,\r\n\t\t\t\t\t\t// matchedChars: characters\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(`Unsupported match result:\\n${JSON.stringify(result, null, 2)}`)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ti++\r\n\t\t}\r\n\t\t// If `last` then overflow has already been checked\r\n\t\t// by the last element of the `tree` array.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (last) {\r\n\t\t\treturn {\r\n\t\t\t\toverflow: true\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tmatch: true,\r\n\t\t\tmatchedChars: characters.slice(0, characters.length - restCharacters.length)\r\n\t\t}\r\n\t}\r\n\r\n\tswitch (tree.op) {\r\n\t\tcase '|':\r\n\t\t\tlet partialMatch\r\n\t\t\tfor (const branch of tree.args) {\r\n\t\t\t\tconst result = match(characters, branch, last)\r\n\t\t\t\tif (result) {\r\n\t\t\t\t\tif (result.overflow) {\r\n\t\t\t\t\t\treturn result\r\n\t\t\t\t\t} else if (result.match) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\t\tmatchedChars: result.matchedChars\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\t\t\tif (result.partialMatch) {\r\n\t\t\t\t\t\t\tpartialMatch = true\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthrow new Error(`Unsupported match result:\\n${JSON.stringify(result, null, 2)}`)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (partialMatch) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tpartialMatch: true,\r\n\t\t\t\t\t// matchedChars: ...\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Not even a partial match.\r\n\t\t\treturn\r\n\r\n\t\tcase '[]':\r\n\t\t\tfor (const char of tree.args) {\r\n\t\t\t\tif (characters[0] === char) {\r\n\t\t\t\t\tif (characters.length === 1) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\t\tmatchedChars: characters\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (last) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\toverflow: true\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\tmatchedChars: [char]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// No character matches.\r\n\t\t\treturn\r\n\r\n\t\t/* istanbul ignore next */\r\n\t\tdefault:\r\n\t\t\tthrow new Error(`Unsupported instruction tree: ${tree}`)\r\n\t}\r\n}\r\n\r\nconst OPERATOR = new RegExp(\r\n\t// any of:\r\n\t'(' +\r\n\t\t// or operator\r\n\t\t'\\\\|' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// or group start\r\n\t\t'\\\\(\\\\?\\\\:' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// or group end\r\n\t\t'\\\\)' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// one-of set start\r\n\t\t'\\\\[' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// one-of set end\r\n\t\t'\\\\]' +\r\n\t')'\r\n)\r\n\r\nconst ILLEGAL_CHARACTER_REGEXP = /[\\(\\)\\[\\]\\?\\:\\|]/\r\n\r\nclass PatternParser {\r\n\tparse(pattern) {\r\n\t\tthis.context = [{\r\n\t\t\tor: true,\r\n\t\t\tinstructions: []\r\n\t\t}]\r\n\r\n\t\tthis.parsePattern(pattern)\r\n\r\n\t\tif (this.context.length !== 1) {\r\n\t\t\tthrow new Error('Non-finalized contexts left when pattern parse ended')\r\n\t\t}\r\n\r\n\t\tconst { branches, instructions } = this.context[0]\r\n\r\n\t\tif (branches) {\r\n\t\t\treturn [{\r\n\t\t\t\top: '|',\r\n\t\t\t\targs: branches.concat([instructions])\r\n\t\t\t}]\r\n\t\t}\r\n\r\n\t\t/* istanbul ignore if */\r\n\t\tif (instructions.length === 0) {\r\n\t\t\tthrow new Error('Pattern is required')\r\n\t\t}\r\n\r\n\t\treturn instructions\r\n\t}\r\n\r\n\tstartContext(context) {\r\n\t\tthis.context.push(context)\r\n\t}\r\n\r\n\tendContext() {\r\n\t\tthis.context.pop()\r\n\t}\r\n\r\n\tgetContext() {\r\n\t\treturn this.context[this.context.length - 1]\r\n\t}\r\n\r\n\tparsePattern(pattern) {\r\n\t\tif (!pattern) {\r\n\t\t\tthrow new Error('Pattern is required')\r\n\t\t}\r\n\r\n\t\tconst match = pattern.match(OPERATOR)\r\n\t\tif (!match) {\r\n\t\t\tif (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {\r\n\t\t\t\tthrow new Error(`Illegal characters found in a pattern: ${pattern}`)\r\n\t\t\t}\r\n\t\t\tthis.getContext().instructions = this.getContext().instructions.concat(\r\n\t\t\t\tpattern.split('')\r\n\t\t\t)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tconst operator = match[1]\r\n\t\tconst before = pattern.slice(0, match.index)\r\n\t\tconst rightPart = pattern.slice(match.index + operator.length)\r\n\r\n\t\tswitch (operator) {\r\n\t\t\tcase '(?:':\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tthis.startContext({\r\n\t\t\t\t\tor: true,\r\n\t\t\t\t\tinstructions: [],\r\n\t\t\t\t\tbranches: []\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase ')':\r\n\t\t\t\tif (!this.getContext().or) {\r\n\t\t\t\t\tthrow new Error('\")\" operator must be preceded by \"(?:\" operator')\r\n\t\t\t\t}\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.getContext().instructions.length === 0) {\r\n\t\t\t\t\tthrow new Error('No instructions found after \"|\" operator in an \"or\" group')\r\n\t\t\t\t}\r\n\t\t\t\tconst { branches } = this.getContext()\r\n\t\t\t\tbranches.push(\r\n\t\t\t\t\tthis.getContext().instructions\r\n\t\t\t\t)\r\n\t\t\t\tthis.endContext()\r\n\t\t\t\tthis.getContext().instructions.push({\r\n\t\t\t\t\top: '|',\r\n\t\t\t\t\targs: branches\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase '|':\r\n\t\t\t\tif (!this.getContext().or) {\r\n\t\t\t\t\tthrow new Error('\"|\" operator can only be used inside \"or\" groups')\r\n\t\t\t\t}\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\t// The top-level is an implicit \"or\" group, if required.\r\n\t\t\t\tif (!this.getContext().branches) {\r\n\t\t\t\t\t// `branches` are not defined only for the root implicit \"or\" operator.\r\n\t\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\t\tif (this.context.length === 1) {\r\n\t\t\t\t\t\tthis.getContext().branches = []\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow new Error('\"branches\" not found in an \"or\" group context')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.getContext().branches.push(\r\n\t\t\t\t\tthis.getContext().instructions\r\n\t\t\t\t)\r\n\t\t\t\tthis.getContext().instructions = []\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase '[':\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tthis.startContext({\r\n\t\t\t\t\toneOfSet: true\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase ']':\r\n\t\t\t\tif (!this.getContext().oneOfSet) {\r\n\t\t\t\t\tthrow new Error('\"]\" operator must be preceded by \"[\" operator')\r\n\t\t\t\t}\r\n\t\t\t\tthis.endContext()\r\n\t\t\t\tthis.getContext().instructions.push({\r\n\t\t\t\t\top: '[]',\r\n\t\t\t\t\targs: parseOneOfSet(before)\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\t/* istanbul ignore next */\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unknown operator: ${operator}`)\r\n\t\t}\r\n\r\n\t\tif (rightPart) {\r\n\t\t\tthis.parsePattern(rightPart)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction parseOneOfSet(pattern) {\r\n\tconst values = []\r\n\tlet i = 0\r\n\twhile (i < pattern.length) {\r\n\t\tif (pattern[i] === '-') {\r\n\t\t\tif (i === 0 || i === pattern.length - 1) {\r\n\t\t\t\tthrow new Error(`Couldn't parse a one-of set pattern: ${pattern}`)\r\n\t\t\t}\r\n\t\t\tconst prevValue = pattern[i - 1].charCodeAt(0) + 1\r\n\t\t\tconst nextValue = pattern[i + 1].charCodeAt(0) - 1\r\n\t\t\tlet value = prevValue\r\n\t\t\twhile (value <= nextValue) {\r\n\t\t\t\tvalues.push(String.fromCharCode(value))\r\n\t\t\t\tvalue++\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvalues.push(pattern[i])\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\treturn values\r\n}"],"file":"AsYouTypeFormatter.PatternMatcher.js"}